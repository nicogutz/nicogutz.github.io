<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>APT Game: Architecture</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">APT Game
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_docs_ARCH.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Architecture </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The main challenge on making this game was ensuring the architecture was MVC, even though finding a consistent definition of MVC was not easy. The first formalization of MVC in a paper from two members of the Smalltalk team. The core ideas and true purpose of MVC is in there. "Models are those components of the system application that actually do the work (simulation of the application domain). They are kept separate from views, which display aspects of the models. Controllers are used to send messages to the model, and provide the interface between the model with its associated views and the interactive user interface devices (e.g., keyboard, mouse)." Each view will be related to one controller, but a model may have many view controller pairs. This is similar to the approach used by modern MVC frameworks such as Spark or Django with a few caveats but all with the same idea. To separate the view from the model as much as possible to maintain true separation of concerns. Django class views for example work with any model, by using a separate Form class that interfaces between both. It makes it so that regardless of the underlying definition of a model, it will be possible to simply drop into a pre made view and use it (in most cases).</p>
<p>This level of decoupling is not trivial to do on a game. Web-apps are inherently data driven, so all changes in the view can be propagated using HTTP to the model and back. It is not the same case for games, which deal with more complex interactions and are less asyncronous in nature.</p>
<p>The definition of a model is not consistent either, In Django, Laravel, and Spring the "models" map instance attributes to columns in a DB (this is necessary for a DAL and it is better defined as an active <a href="https://martinfowler.com/eaaCatalog/activerecord.html">record</a>/<a href="https://martinfowler.com/eaaCatalog/repository.html">repository</a>. When instantiating a "model" in that case, you are really accessing the underlying table through a class. The class can then query the table and return the data using the same class. It makes programming much simpler, but leads many people to think that all classes with data in them are models. "The behavior required of models is the ability to have dependents and the ability to broadcast change messages to their dependents. Models hold onto a collection of their dependent objects. The class Model has message protocol to add and remove dependents from this collection.". Therefore a class that stores some data is closer to a Domain Object (<a href="https://wiki.c2.com/?DomainObject">https://wiki.c2.com/?DomainObject</a>), and a store of those Domain Objects is more accurately defined as a model. This is also somewhat similar to the ideas in modern MVC, with changes in nomenclature depending on the framework.</p>
<p>The responsibility of handling user input is mostly left open. It is very dependent on the framework and the type of input the user can do.</p>
<p>With this in mind, the following architecture was developed for the game. Keeping in mind that the parent/child relationship between the <a class="el" href="classGameWindow.html" title="The GameWindow class is the main window for the game.">GameWindow</a> and the <a class="el" href="classGameController.html" title="The GameController class holds all the models and the view. It directs the user input and the game st...">GameController</a> is necessary for Qt but not part of MVC in any way.</p>
<p><img src="image.png" alt="" class="inline" title="Main Classes"/></p>
<p>The <a class="el" href="classGameController.html#ab39b82fa89135c209151738911d2dc5d" title="dataChanged captures any model changes and filters to call corresponding methods.">GameController::dataChanged</a> signal is connected to the <a class="el" href="classGameView.html#a910d07857d706e405f3fc28e8d4eb2a8" title="dataChanged is the slot to monitor the change of properties of any object in the scene.">GameView::dataChanged</a> slot. Whenever there is a change in the model, it emits a signal with a QMap&lt; DataRole, QVariant &gt;. Enough information is encoded here for the view to make any changes necessary to the visualization of the game. It does this without ever knowing that GameObjects or GameObjectModels exist. This makes it incredibly flexible, especially since the controller is the one handling the connections.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Important Signals/Slots/Actions</h1>
<p>The following diagram shows how each class interacts with the others. Solid lines represent direct connections, while dotted lines represent signals/slots. <img src="image-1.png" alt="" class="inline" title="Alt text"/></p>
<p>The flexibility of this lies in how the connections are propagated. The user makes an action either through the keyboard, with the text input, or clicks a button in the <a class="el" href="classGameWindow.html" title="The GameWindow class is the main window for the game.">GameWindow</a> UI. This will make the <a class="el" href="classGameWindow.html" title="The GameWindow class is the main window for the game.">GameWindow</a> send the correct action to the <a class="el" href="classGameController.html" title="The GameController class holds all the models and the view. It directs the user input and the game st...">GameController</a>. Moving the protagonist/attacking an enemy. The controller always keeps a pointer to the <a class="el" href="classGameObject.html" title="The GameObject class represents an individual entity within the game world, capable of various intera...">GameObject</a> of the character for performance reasons (it can look for any object in the model but it takes some time). The controller gets the appropriate action, triggers it, and then emits a tick signal. When GameObjects/GameObjectModels are created, their children are set since they are all QObjects, the parent also connects the childs dataChanged and tick signal to its own. If the child is not passed on creation, this has to be done manually. The ticks make all of the behaviors that are time based work for one "cycle". The behavior then can call an arbitrary number of behaviors, and it might or might not change any data in any/all GameObjects. When any data is changed, the <a class="el" href="classGameObject.html" title="The GameObject class represents an individual entity within the game world, capable of various intera...">GameObject</a> will emit a signal <a class="el" href="classGameObject.html#a804af99d55508c0ee4eaed5f0ead440b" title="Signal emitted when the data of the GameObject changes.">GameObject::dataChanged</a>. This will propagate the signal through the tree until it finally reaches the <a class="el" href="classGameObjectModel.html" title="The GameObjectModel class represents the model of the game world. It holds a grid of GameObject point...">GameObjectModel</a>. The signal in the active <a class="el" href="classGameObjectModel.html" title="The GameObjectModel class represents the model of the game world. It holds a grid of GameObject point...">GameObjectModel</a> is connected to the <a class="el" href="classGameView.html#a910d07857d706e405f3fc28e8d4eb2a8" title="dataChanged is the slot to monitor the change of properties of any object in the scene.">GameView::dataChanged</a> slot, as well as the <a class="el" href="classGameController.html#ab39b82fa89135c209151738911d2dc5d" title="dataChanged captures any model changes and filters to call corresponding methods.">GameController::dataChanged</a> slot. These two will handle the changes in whatever way is best.</p>
<p>The importance of the signal propagation is that when a level changes, the only thing the controller has to do is make a new Scene with the <a class="el" href="classGameView.html#a64021906798c8b3e083e2c43b246fb4f" title="createScene creates the full scene of the gameObjects. passed to it to visualize based on the rendere...">GameView::createScene</a> (which clears the scene and destroys all previous pixmaps) and disconnect the 3 slots. When the world is accessed again, it simply has to connect them. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
